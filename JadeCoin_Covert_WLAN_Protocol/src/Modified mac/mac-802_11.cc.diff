/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-	/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-
 *								 *
 * Copyright (c) 1997 Regents of the University of California	 * Copyright (c) 1997 Regents of the University of California
 * All rights reserved.						 * All rights reserved.
 *								 *
 * Redistribution and use in source and binary forms, with or	 * Redistribution and use in source and binary forms, with or
 * modification, are permitted provided that the following co	 * modification, are permitted provided that the following co
 * are met:							 * are met:
 * 1. Redistributions of source code must retain the above co	 * 1. Redistributions of source code must retain the above co
 *    notice, this list of conditions and the following discl	 *    notice, this list of conditions and the following discl
 * 2. Redistributions in binary form must reproduce the above	 * 2. Redistributions in binary form must reproduce the above
 *    notice, this list of conditions and the following discl	 *    notice, this list of conditions and the following discl
 *    documentation and/or other materials provided with the 	 *    documentation and/or other materials provided with the 
 * 3. All advertising materials mentioning features or use of	 * 3. All advertising materials mentioning features or use of
 *    must display the following acknowledgement:		 *    must display the following acknowledgement:
 *	This product includes software developed by the Compu	 *	This product includes software developed by the Compu
 *	Engineering Group at Lawrence Berkeley Laboratory.	 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laborator	 * 4. Neither the name of the University nor of the Laborator
 *    to endorse or promote products derived from this softwa	 *    to endorse or promote products derived from this softwa
 *    specific prior written permission.			 *    specific prior written permission.
 *								 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS 	 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMI	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMI
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PA	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PA
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBU	 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBU
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 	 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUB	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUB
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS IN	 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS IN
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARI	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARI
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE PO	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE PO
 * SUCH DAMAGE.							 * SUCH DAMAGE.
 *								 *
 * $Header: /nfs/jade/vint/CVSROOT/ns-2/mac/mac-802_11.cc,v 1	 * $Header: /nfs/jade/vint/CVSROOT/ns-2/mac/mac-802_11.cc,v 1
 *								 *
 * Ported from CMU/Monarch's code, nov'98 -Padma.		 * Ported from CMU/Monarch's code, nov'98 -Padma.
 * Contributions by:						 * Contributions by:
 *   - Mike Holland						 *   - Mike Holland
 *   - Sushmita							 *   - Sushmita
 */								 */

#include "delay.h"						#include "delay.h"
#include "connector.h"						#include "connector.h"
#include "packet.h"						#include "packet.h"
#include "random.h"						#include "random.h"
#include "mobilenode.h"						#include "mobilenode.h"

// #define DEBUG 99						// #define DEBUG 99

#include "arp.h"						#include "arp.h"
#include "ll.h"							#include "ll.h"
#include "mac.h"						#include "mac.h"
#include "mac-timers.h"						#include "mac-timers.h"
#include "mac-802_11.h"						#include "mac-802_11.h"
#include "cmu-trace.h"						#include "cmu-trace.h"
							      |	#include "../JadeCoin/jadecoin.h"
// Added by Sushmita to support event tracing			// Added by Sushmita to support event tracing
#include "agent.h"						#include "agent.h"
#include "basetrace.h"						#include "basetrace.h"


/* our backoff timer doesn't count down in idle times during 	/* our backoff timer doesn't count down in idle times during 
 * frame-exchange sequence as the mac tx state isn't idle; ge	 * frame-exchange sequence as the mac tx state isn't idle; ge
 * these idle times are less than DIFS and won't contribute t	 * these idle times are less than DIFS and won't contribute t
 * counting down the backoff period, but this could be a real	 * counting down the backoff period, but this could be a real
 * problem if the frame exchange ends up in a timeout! in tha	 * problem if the frame exchange ends up in a timeout! in tha
 * i.e. if a timeout happens we've not been counting down for	 * i.e. if a timeout happens we've not been counting down for
 * duration of the timeout, and in fact begin counting down o	 * duration of the timeout, and in fact begin counting down o
 * DIFS after the timeout!! we lose the timeout interval - wh	 * DIFS after the timeout!! we lose the timeout interval - wh
 * will is not the REAL case! also, the backoff timer could b	 * will is not the REAL case! also, the backoff timer could b
 * and we could have a pending transmission which we could ha	 * and we could have a pending transmission which we could ha
 * sent! one could argue this is an implementation artifact w	 * sent! one could argue this is an implementation artifact w
 * doesn't violate the spec.. and the timeout interval is exp	 * doesn't violate the spec.. and the timeout interval is exp
 * to be less than DIFS .. which means its not a lot of time 	 * to be less than DIFS .. which means its not a lot of time 
 * lose.. anyway if everyone hears everyone the only reason a	 * lose.. anyway if everyone hears everyone the only reason a
 * be delayed will be due to a collision => the medium won't 	 * be delayed will be due to a collision => the medium won't 
 * idle for a DIFS for this to really matter!!			 * idle for a DIFS for this to really matter!!
 */								 */

inline void							inline void
Mac802_11::checkBackoffTimer()					Mac802_11::checkBackoffTimer()
{								{
	if(is_idle() && mhBackoff_.paused())				if(is_idle() && mhBackoff_.paused())
		mhBackoff_.resume(phymib_.getDIFS());				mhBackoff_.resume(phymib_.getDIFS());
	if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.p		if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.p
		mhBackoff_.pause();						mhBackoff_.pause();
}								}

inline void							inline void
Mac802_11::transmit(Packet *p, double timeout)			Mac802_11::transmit(Packet *p, double timeout)
{								{
	tx_active_ = 1;							tx_active_ = 1;
									
	if (EOTtarget_) {						if (EOTtarget_) {
		assert (eotPacket_ == NULL);					assert (eotPacket_ == NULL);
		eotPacket_ = p->copy();						eotPacket_ = p->copy();
	}								}

	/*								/*
	 * If I'm transmitting without doing CS, such as when		 * If I'm transmitting without doing CS, such as when
	 * sending an ACK, any incoming packet will be "misse		 * sending an ACK, any incoming packet will be "misse
	 * and hence, must be discarded.				 * and hence, must be discarded.
	 */								 */
	if(rx_state_ != MAC_IDLE) {					if(rx_state_ != MAC_IDLE) {
		struct hdr_mac802_11 *dh = HDR_MAC802_11(p);			struct hdr_mac802_11 *dh = HDR_MAC802_11(p);
		assert(dh->dh_fc.fc_type == MAC_Type_Control)			assert(dh->dh_fc.fc_type == MAC_Type_Control)
		assert(dh->dh_fc.fc_subtype == MAC_Subtype_AC			assert(dh->dh_fc.fc_subtype == MAC_Subtype_AC
		assert(pktRx_);							assert(pktRx_);
		struct hdr_cmn *ch = HDR_CMN(pktRx_);				struct hdr_cmn *ch = HDR_CMN(pktRx_);
		ch->error() = 1;        /* force packet disca			ch->error() = 1;        /* force packet disca
	}								}

	/*								/*
	 * pass the packet on the "interface" which will in t		 * pass the packet on the "interface" which will in t
	 * place the packet on the channel.				 * place the packet on the channel.
	 *								 *
	 * NOTE: a handler is passed along so that the Networ		 * NOTE: a handler is passed along so that the Networ
	 *       Interface can distinguish between incoming a		 *       Interface can distinguish between incoming a
	 *       outgoing packets.					 *       outgoing packets.
	 */								 */
	downtarget_->recv(p->copy(), this);				downtarget_->recv(p->copy(), this);	
	mhSend_.start(timeout);						mhSend_.start(timeout);
	// Only want to check on X-mission				// Only want to check on X-mission
	if (p == pktTx_)						if (p == pktTx_)
		mhCollision_.start(timeout);		      |			listenForCollisions = true;
	mhIF_.start(txtime(p));						mhIF_.start(txtime(p));
}								}
inline void							inline void
Mac802_11::setRxState(MacState newState)			Mac802_11::setRxState(MacState newState)
{								{
	rx_state_ = newState;						rx_state_ = newState;
	checkBackoffTimer();						checkBackoffTimer();
}								}

inline void							inline void
Mac802_11::setTxState(MacState newState)			Mac802_11::setTxState(MacState newState)
{								{
	tx_state_ = newState;						tx_state_ = newState;
	checkBackoffTimer();						checkBackoffTimer();
}								}


/* ==========================================================	/* ==========================================================
   TCL Hooks for the simulator					   TCL Hooks for the simulator
   ==========================================================	   ==========================================================
static class Mac802_11Class : public TclClass {			static class Mac802_11Class : public TclClass {
public:								public:
	Mac802_11Class() : TclClass("Mac/802_11") {}			Mac802_11Class() : TclClass("Mac/802_11") {}
	TclObject* create(int, const char*const*) {			TclObject* create(int, const char*const*) {
	return (new Mac802_11());					return (new Mac802_11());

}								}
} class_mac802_11;						} class_mac802_11;


/* ==========================================================	/* ==========================================================
   Mac  and Phy MIB Class Functions				   Mac  and Phy MIB Class Functions
   ==========================================================	   ==========================================================

PHY_MIB::PHY_MIB(Mac802_11 *parent)				PHY_MIB::PHY_MIB(Mac802_11 *parent)
{								{
	/*								/*
	 * Bind the phy mib objects.  Note that these will be		 * Bind the phy mib objects.  Note that these will be
	 * to Mac/802_11 variables					 * to Mac/802_11 variables
	 */								 */

	parent->bind("CWMin_", &CWMin);					parent->bind("CWMin_", &CWMin);
	parent->bind("CWMax_", &CWMax);					parent->bind("CWMax_", &CWMax);
	parent->bind("SlotTime_", &SlotTime);				parent->bind("SlotTime_", &SlotTime);
	parent->bind("SIFS_", &SIFSTime);				parent->bind("SIFS_", &SIFSTime);
	parent->bind("PreambleLength_", &PreambleLength);		parent->bind("PreambleLength_", &PreambleLength);
	parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);		parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);
	parent->bind_bw("PLCPDataRate_", &PLCPDataRate);		parent->bind_bw("PLCPDataRate_", &PLCPDataRate);
}							      <

							      >	}
MAC_MIB::MAC_MIB(Mac802_11 *parent)				MAC_MIB::MAC_MIB(Mac802_11 *parent)
{								{
	/*								/*
	 * Bind the phy mib objects.  Note that these will be		 * Bind the phy mib objects.  Note that these will be
	 * to Mac/802_11 variables					 * to Mac/802_11 variables
	 */								 */
							      <
	parent->bind("RTSThreshold_", &RTSThreshold);			parent->bind("RTSThreshold_", &RTSThreshold);
	parent->bind("ShortRetryLimit_", &ShortRetryLimit);		parent->bind("ShortRetryLimit_", &ShortRetryLimit);
	parent->bind("LongRetryLimit_", &LongRetryLimit);		parent->bind("LongRetryLimit_", &LongRetryLimit);
}								}

/* ==========================================================	/* ==========================================================
   Mac Class Functions						   Mac Class Functions
   ==========================================================	   ==========================================================
Mac802_11::Mac802_11() : 					Mac802_11::Mac802_11() : 
	Mac(), phymib_(this), macmib_(this), mhIF_(this), mhN		Mac(), phymib_(this), macmib_(this), mhIF_(this), mhN
	mhRecv_(this), mhSend_(this), mhJam_(this), 			mhRecv_(this), mhSend_(this), mhJam_(this), 
	mhDefer_(this), mhBackoff_(this), mhCollision_(this)  |		mhDefer_(this), mhBackoff_(this) 
{								{
							      |		bytesSent = 0;	
	nav_ = 0.0;							nav_ = 0.0;
	tx_state_ = rx_state_ = MAC_IDLE;				tx_state_ = rx_state_ = MAC_IDLE;
	tx_active_ = 0;							tx_active_ = 0;
	eotPacket_ = NULL;						eotPacket_ = NULL;
	pktRTS_ = 0;							pktRTS_ = 0;
	pktCTRL_ = 0;					      |		pktJAM_ = pktCTRL_ = 0;		
	cw_ = phymib_.getCWMin();					cw_ = phymib_.getCWMin();
	ssrc_ = slrc_ = 0;						ssrc_ = slrc_ = 0;
							      >		listenForCollisions = false;
	// Added by Sushmita						// Added by Sushmita
        et_ = new EventTrace();					        et_ = new EventTrace();
									
	sta_seqno_ = 1;							sta_seqno_ = 1;
	cache_ = 0;							cache_ = 0;
	cache_node_count_ = 0;						cache_node_count_ = 0;
									
	// chk if basic/data rates are set				// chk if basic/data rates are set
	// otherwise use bandwidth_ as default;				// otherwise use bandwidth_ as default;
									
	Tcl& tcl = Tcl::instance();					Tcl& tcl = Tcl::instance();
	tcl.evalf("Mac/802_11 set basicRate_");				tcl.evalf("Mac/802_11 set basicRate_");
	if (strcmp(tcl.result(), "0") != 0) 				if (strcmp(tcl.result(), "0") != 0) 
		bind_bw("basicRate_", &basicRate_);				bind_bw("basicRate_", &basicRate_);
	else								else
		basicRate_ = bandwidth_;					basicRate_ = bandwidth_;

	tcl.evalf("Mac/802_11 set dataRate_");				tcl.evalf("Mac/802_11 set dataRate_");
	if (strcmp(tcl.result(), "0") != 0) 				if (strcmp(tcl.result(), "0") != 0) 
		bind_bw("dataRate_", &dataRate_);				bind_bw("dataRate_", &dataRate_);
	else								else
		dataRate_ = bandwidth_;						dataRate_ = bandwidth_;

        EOTtarget_ = 0;					      |	  EOTtarget_ = 0;
       	bss_id_ = IBSS_ID;				      |	  bss_id_ = IBSS_ID;
	//printf("bssid in constructor %d\n",bss_id_);			//printf("bssid in constructor %d\n",bss_id_);
	mhCollision_.setSlotTime(phymib_.getSlotTime());      |		
}								}


int								int
Mac802_11::command(int argc, const char*const* argv)		Mac802_11::command(int argc, const char*const* argv)
{								{
	if (argc == 3) {						if (argc == 3) {
		if (strcmp(argv[1], "eot-target") == 0) {			if (strcmp(argv[1], "eot-target") == 0) {
			EOTtarget_ = (NsObject*) TclObject::l				EOTtarget_ = (NsObject*) TclObject::l
			if (EOTtarget_ == 0)						if (EOTtarget_ == 0)
				return TCL_ERROR;						return TCL_ERROR;
			return TCL_OK;							return TCL_OK;
		} else if (strcmp(argv[1], "bss_id") == 0) {			} else if (strcmp(argv[1], "bss_id") == 0) {
			bss_id_ = atoi(argv[2]);					bss_id_ = atoi(argv[2]);
			return TCL_OK;							return TCL_OK;
							      >			} else if (strcmp(argv[1], "listenForCollisio
							      >				listenForCollisions = (bool) atoi(arg
							      >				return TCL_OK;
		} else if (strcmp(argv[1], "log-target") == 0			} else if (strcmp(argv[1], "log-target") == 0
			logtarget_ = (NsObject*) TclObject::l				logtarget_ = (NsObject*) TclObject::l
			if(logtarget_ == 0)						if(logtarget_ == 0)
				return TCL_ERROR;						return TCL_ERROR;
			return TCL_OK;							return TCL_OK;
		} else if(strcmp(argv[1], "nodes") == 0) {			} else if(strcmp(argv[1], "nodes") == 0) {
			if(cache_) return TCL_ERROR;					if(cache_) return TCL_ERROR;
			cache_node_count_ = atoi(argv[2]);				cache_node_count_ = atoi(argv[2]);
			cache_ = new Host[cache_node_count_ +				cache_ = new Host[cache_node_count_ +
			assert(cache_);							assert(cache_);
			bzero(cache_, sizeof(Host) * (cache_n				bzero(cache_, sizeof(Host) * (cache_n
			return TCL_OK;							return TCL_OK;
							      >			} else if(strcmp(argv[1], "get-mac") == 0) {
							      >				/**
							      >				 * This will return this Mac802_11 to
							      >				 */
							      >				Tcl& tcl = Tcl::instance();
							      >				tcl.resultf("%u", this);
							      >				return TCL_OK;		
		} else if(strcmp(argv[1], "eventtrace") == 0)			} else if(strcmp(argv[1], "eventtrace") == 0)
			// command added to support event tra				// command added to support event tra
                        et_ = (EventTrace *)TclObject::lookup |	       et_ = (EventTrace *)TclObject::lookup(argv[2]);
                        return (TCL_OK);		      |	       return (TCL_OK);
                }					      |	    }
	}								}
	return Mac::command(argc, argv);		      |		return Mac::command(argc, argv); 
}								}

// Added by Sushmita to support event tracing			// Added by Sushmita to support event tracing
void Mac802_11::trace_event(char *eventtype, Packet *p) 	void Mac802_11::trace_event(char *eventtype, Packet *p) 
{								{
        if (et_ == NULL) return;				        if (et_ == NULL) return;
        char *wrk = et_->buffer();				        char *wrk = et_->buffer();
        char *nwrk = et_->nbuffer();				        char *nwrk = et_->nbuffer();
									
        hdr_ip *iph = hdr_ip::access(p);			        hdr_ip *iph = hdr_ip::access(p);
        //char *src_nodeaddr =					        //char *src_nodeaddr =
	//       Address::instance().print_nodeaddr(iph->sadd		//       Address::instance().print_nodeaddr(iph->sadd
        //char *dst_nodeaddr =					        //char *dst_nodeaddr =
        //      Address::instance().print_nodeaddr(iph->daddr	        //      Address::instance().print_nodeaddr(iph->daddr
									
        struct hdr_mac802_11* dh = HDR_MAC802_11(p);		        struct hdr_mac802_11* dh = HDR_MAC802_11(p);
									
        //struct hdr_cmn *ch = HDR_CMN(p);			        //struct hdr_cmn *ch = HDR_CMN(p);
									
	if(wrk != 0) {							if(wrk != 0) {
		sprintf(wrk, "E -t "TIME_FORMAT" %s %2x ",			sprintf(wrk, "E -t "TIME_FORMAT" %s %2x ",
			et_->round(Scheduler::instance().cloc				et_->round(Scheduler::instance().cloc
                        eventtype,				                        eventtype,
                        //ETHER_ADDR(dh->dh_sa)			                        //ETHER_ADDR(dh->dh_sa)
                        ETHER_ADDR(dh->dh_ta)			                        ETHER_ADDR(dh->dh_ta)
                        );					                        );
        }							        }
        if(nwrk != 0) {						        if(nwrk != 0) {
                sprintf(nwrk, "E -t "TIME_FORMAT" %s %2x ",	                sprintf(nwrk, "E -t "TIME_FORMAT" %s %2x ",
                        et_->round(Scheduler::instance().cloc	                        et_->round(Scheduler::instance().cloc
                        eventtype,				                        eventtype,
                        //ETHER_ADDR(dh->dh_sa)			                        //ETHER_ADDR(dh->dh_sa)
                        ETHER_ADDR(dh->dh_ta)			                        ETHER_ADDR(dh->dh_ta)
                        );					                        );
        }							        }
        et_->dump();						        et_->dump();
}								}

/* ==========================================================	/* ==========================================================
   Debugging Routines						   Debugging Routines
   ==========================================================	   ==========================================================
void								void
Mac802_11::trace_pkt(Packet *p) 				Mac802_11::trace_pkt(Packet *p) 
{								{
	struct hdr_cmn *ch = HDR_CMN(p);				struct hdr_cmn *ch = HDR_CMN(p);
	struct hdr_mac802_11* dh = HDR_MAC802_11(p);			struct hdr_mac802_11* dh = HDR_MAC802_11(p);
	u_int16_t *t = (u_int16_t*) &dh->dh_fc;				u_int16_t *t = (u_int16_t*) &dh->dh_fc;

	fprintf(stderr, "\t[ %2x %2x %2x %2x ] %x %s %d\n",		fprintf(stderr, "\t[ %2x %2x %2x %2x ] %x %s %d\n",
		*t, dh->dh_duration,						*t, dh->dh_duration,
		 ETHER_ADDR(dh->dh_ra), ETHER_ADDR(dh->dh_ta)			 ETHER_ADDR(dh->dh_ra), ETHER_ADDR(dh->dh_ta)
		index_, packet_info.name(ch->ptype()), ch->si			index_, packet_info.name(ch->ptype()), ch->si
}								}

void								void
Mac802_11::dump(char *fname)					Mac802_11::dump(char *fname)
{								{
	fprintf(stderr,							fprintf(stderr,
		"\n%s --- (INDEX: %d, time: %2.9f)\n",				"\n%s --- (INDEX: %d, time: %2.9f)\n",
		fname, index_, Scheduler::instance().clock())			fname, index_, Scheduler::instance().clock())

	fprintf(stderr,							fprintf(stderr,
		"\ttx_state_: %x, rx_state_: %x, nav: %2.9f, 			"\ttx_state_: %x, rx_state_: %x, nav: %2.9f, 
		tx_state_, rx_state_, nav_, is_idle());				tx_state_, rx_state_, nav_, is_idle());

	fprintf(stderr,							fprintf(stderr,
		"\tpktTx_: %x, pktRx_: %x, pktRTS_: %x, pktCT			"\tpktTx_: %x, pktRx_: %x, pktRTS_: %x, pktCT
		(int) pktTx_, (int) pktRx_, (int) pktRTS_,			(int) pktTx_, (int) pktRx_, (int) pktRTS_,
		(int) pktCTRL_, (int) callback_);				(int) pktCTRL_, (int) callback_);

	fprintf(stderr,							fprintf(stderr,
		"\tDefer: %d, Backoff: %d (%d), Recv: %d, Tim			"\tDefer: %d, Backoff: %d (%d), Recv: %d, Tim
		mhDefer_.busy(), mhBackoff_.busy(), mhBackoff			mhDefer_.busy(), mhBackoff_.busy(), mhBackoff
		mhRecv_.busy(), mhSend_.busy(), mhNav_.busy()			mhRecv_.busy(), mhSend_.busy(), mhNav_.busy()
	fprintf(stderr,							fprintf(stderr,
		"\tBackoff Expire: %f\n",					"\tBackoff Expire: %f\n",
		mhBackoff_.expire());						mhBackoff_.expire());
}								}


/* ==========================================================	/* ==========================================================
   Packet Headers Routines					   Packet Headers Routines
   ==========================================================	   ==========================================================
inline int							inline int
Mac802_11::hdr_dst(char* hdr, int dst )				Mac802_11::hdr_dst(char* hdr, int dst )
{								{
	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd		struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd
									
       if (dst > -2) {						       if (dst > -2) {
               if ((bss_id() == IBSS_ID) || (addr() == bss_id	               if ((bss_id() == IBSS_ID) || (addr() == bss_id
                       /* if I'm AP (2nd condition above!), t	                       /* if I'm AP (2nd condition above!), t
                        * is already set by the MAC whilst fw	                        * is already set by the MAC whilst fw
                        * locally originated pkt, it might ma	                        * locally originated pkt, it might ma
                        * to set the dh_3a to myself here! do	                        * to set the dh_3a to myself here! do
                        * how to distinguish between the two 	                        * how to distinguish between the two 
                        * the info is not critical to the dst	                        * the info is not critical to the dst
                        * anyway!				                        * anyway!
                        */					                        */
                       STORE4BYTE(&dst, (dh->dh_ra));		                       STORE4BYTE(&dst, (dh->dh_ra));
               } else {						               } else {
                       /* in BSS mode, the AP forwards everyt	                       /* in BSS mode, the AP forwards everyt
                        * therefore, the real dest goes in th	                        * therefore, the real dest goes in th
                        * address, and the AP address goes in	                        * address, and the AP address goes in
                        * destination address			                        * destination address
                        */					                        */
                       STORE4BYTE(&bss_id_, (dh->dh_ra));	                       STORE4BYTE(&bss_id_, (dh->dh_ra));
                       STORE4BYTE(&dst, (dh->dh_3a));		                       STORE4BYTE(&dst, (dh->dh_3a));
               }						               }
       }							       }


       return (u_int32_t)ETHER_ADDR(dh->dh_ra);			       return (u_int32_t)ETHER_ADDR(dh->dh_ra);
}								}

inline int 							inline int 
Mac802_11::hdr_src(char* hdr, int src )				Mac802_11::hdr_src(char* hdr, int src )
{								{
	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd		struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd
        if(src > -2)						        if(src > -2)
               STORE4BYTE(&src, (dh->dh_ta));			               STORE4BYTE(&src, (dh->dh_ta));
        return ETHER_ADDR(dh->dh_ta);				        return ETHER_ADDR(dh->dh_ta);
}								}

inline int 							inline int 
Mac802_11::hdr_type(char* hdr, u_int16_t type)			Mac802_11::hdr_type(char* hdr, u_int16_t type)
{								{
	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd		struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hd
	if(type)							if(type)
		STORE2BYTE(&type,(dh->dh_body));				STORE2BYTE(&type,(dh->dh_body));
	return GET2BYTE(dh->dh_body);					return GET2BYTE(dh->dh_body);
}								}


/* ==========================================================	/* ==========================================================
   Misc Routines						   Misc Routines
   ==========================================================	   ==========================================================
inline int							inline int
Mac802_11::is_idle()						Mac802_11::is_idle()
{								{
	if(rx_state_ != MAC_IDLE)					if(rx_state_ != MAC_IDLE)
		return 0;							return 0;
	if(tx_state_ != MAC_IDLE)					if(tx_state_ != MAC_IDLE)
		return 0;							return 0;
	if(nav_ > Scheduler::instance().clock())			if(nav_ > Scheduler::instance().clock())
		return 0;							return 0;
									
	return 1;							return 1;
}								}

void								void
Mac802_11::discard(Packet *p, const char* why)			Mac802_11::discard(Packet *p, const char* why)
{								{
	hdr_mac802_11* mh = HDR_MAC802_11(p);				hdr_mac802_11* mh = HDR_MAC802_11(p);
	hdr_cmn *ch = HDR_CMN(p);					hdr_cmn *ch = HDR_CMN(p);

	/* if the rcvd pkt contains errors, a real MAC layer 		/* if the rcvd pkt contains errors, a real MAC layer 
	   necessarily read any data from it, so we just toss		   necessarily read any data from it, so we just toss
	if(ch->error() != 0) {						if(ch->error() != 0) {
		Packet::free(p);						Packet::free(p);
		return;								return;
	}								}

	switch(mh->dh_fc.fc_type) {					switch(mh->dh_fc.fc_type) {
	case MAC_Type_Management:					case MAC_Type_Management:
		drop(p, why);							drop(p, why);
		return;								return;
	case MAC_Type_Control:						case MAC_Type_Control:
		switch(mh->dh_fc.fc_subtype) {					switch(mh->dh_fc.fc_subtype) {
		case MAC_Subtype_RTS:						case MAC_Subtype_RTS:
			 if((u_int32_t)ETHER_ADDR(mh->dh_ta) 				 if((u_int32_t)ETHER_ADDR(mh->dh_ta) 
				drop(p, why);							drop(p, why);
				return;								return;
			}								}
			/* fall through - if necessary */				/* fall through - if necessary */
		case MAC_Subtype_CTS:						case MAC_Subtype_CTS:
		case MAC_Subtype_ACK:						case MAC_Subtype_ACK:
			if((u_int32_t)ETHER_ADDR(mh->dh_ra) =				if((u_int32_t)ETHER_ADDR(mh->dh_ra) =
				drop(p, why);							drop(p, why);
				return;								return;
			}								}
			break;								break;
		default:							default:
			fprintf(stderr, "invalid MAC Control 				fprintf(stderr, "invalid MAC Control 
			exit(1);							exit(1);
		}								}
		break;								break;
	case MAC_Type_Data:						case MAC_Type_Data:
		switch(mh->dh_fc.fc_subtype) {					switch(mh->dh_fc.fc_subtype) {
		case MAC_Subtype_Data:						case MAC_Subtype_Data:
			if((u_int32_t)ETHER_ADDR(mh->dh_ra) =				if((u_int32_t)ETHER_ADDR(mh->dh_ra) =
                           (u_int32_t)index_ ||			                           (u_int32_t)index_ ||
                          (u_int32_t)ETHER_ADDR(mh->dh_ta) ==	                          (u_int32_t)ETHER_ADDR(mh->dh_ta) ==
                           (u_int32_t)index_ ||			                           (u_int32_t)index_ ||
                          (u_int32_t)ETHER_ADDR(mh->dh_ra) ==	                          (u_int32_t)ETHER_ADDR(mh->dh_ra) ==
                                drop(p,why);			                                drop(p,why);
                                return;				                                return;
			}								}
			break;								break;
		default:							default:
			fprintf(stderr, "invalid MAC Data sub				fprintf(stderr, "invalid MAC Data sub
			exit(1);							exit(1);
		}								}
		break;								break;
	case MAC_Type_JAM:						case MAC_Type_JAM:
		switch(mh->dh_fc.fc_subtype)					switch(mh->dh_fc.fc_subtype)
		{								{
			case MAC_Subtype_NO_JAM:					case MAC_Subtype_NO_JAM:
					drop(p,why);							drop(p,why);
					break;								break;
			case MAC_Subtype_JAM:						case MAC_Subtype_JAM:
					drop(p,why);							drop(p,why);
					break;								break;
			default:							default:
				fprintf(stderr, "invalid MAC 					fprintf(stderr, "invalid MAC 
		}								}
		break;								break;
	default:							default:
		fprintf(stderr, "invalid MAC type (%x)\n", mh			fprintf(stderr, "invalid MAC type (%x)\n", mh
		trace_pkt(p);							trace_pkt(p);
		exit(1);							exit(1);
	}								}
	Packet::free(p);						Packet::free(p);
}								}

void								void
Mac802_11::capture(Packet *p)					Mac802_11::capture(Packet *p)
{								{
	/*								/*
	 * Update the NAV so that this does not screw			 * Update the NAV so that this does not screw
	 * up carrier sense.						 * up carrier sense.
	 */								 */	
	set_nav(usec(phymib_.getEIFS() + txtime(p)));			set_nav(usec(phymib_.getEIFS() + txtime(p)));
	Packet::free(p);						Packet::free(p);
}								}

void								void
Mac802_11::collision(Packet *p)					Mac802_11::collision(Packet *p)
{								{
	switch(rx_state_) {						switch(rx_state_) {
	case MAC_RECV:							case MAC_RECV:
		setRxState(MAC_COLL);						setRxState(MAC_COLL);
		/* fall through */						/* fall through */
	case MAC_COLL:							case MAC_COLL:
		assert(pktRx_);							assert(pktRx_);
		assert(mhRecv_.busy());						assert(mhRecv_.busy());
		/*								/*
		 *  Since a collision has occurred, figure ou			 *  Since a collision has occurred, figure ou
		 *  which packet that caused the collision wi			 *  which packet that caused the collision wi
		 *  "last" the longest.  Make this packet,			 *  "last" the longest.  Make this packet,
		 *  pktRx_ and reset the Recv Timer if necess			 *  pktRx_ and reset the Recv Timer if necess
		 */								 */
										
		if(txtime(p) > mhRecv_.expire()) {				if(txtime(p) > mhRecv_.expire()) {
			mhRecv_.stop();							mhRecv_.stop();
			discard(pktRx_, DROP_MAC_COLLISION);				discard(pktRx_, DROP_MAC_COLLISION);
			pktRx_ = p;							pktRx_ = p;
			mhRecv_.start(txtime(pktRx_));					mhRecv_.start(txtime(pktRx_));
		}								}
		else {								else {
			discard(p, DROP_MAC_COLLISION);					discard(p, DROP_MAC_COLLISION);
		}								}
		break;								break;
	default:							default:
		assert(0);							assert(0);
	}								}
	recvJAM();					      |		if(listenForCollisions)
							      >		1;	//recvJAM();
}								}

void								void
Mac802_11::tx_resume()						Mac802_11::tx_resume()
{								{
	double rTime;							double rTime;
	assert(mhSend_.busy() == 0);					assert(mhSend_.busy() == 0);
	assert(mhDefer_.busy() == 0);					assert(mhDefer_.busy() == 0);

	if(pktCTRL_) {							if(pktCTRL_) {
		/*								/*
		 *  Need to send a CTS or ACK.					 *  Need to send a CTS or ACK.
		 */								 */
		mhDefer_.start(phymib_.getSIFS());				mhDefer_.start(phymib_.getSIFS());
	} else if(pktRTS_) {						} else if(pktRTS_) {
		if (mhBackoff_.busy() == 0) {					if (mhBackoff_.busy() == 0) {
			rTime = (Random::random() % cw_) * ph				rTime = (Random::random() % cw_) * ph
			mhDefer_.start( phymib_.getDIFS() + r				mhDefer_.start( phymib_.getDIFS() + r
		}								}
	} else if(pktTx_) {						} else if(pktTx_) {
		if (mhBackoff_.busy() == 0) {					if (mhBackoff_.busy() == 0) {
			hdr_cmn *ch = HDR_CMN(pktTx_);					hdr_cmn *ch = HDR_CMN(pktTx_);
			struct hdr_mac802_11 *mh = HDR_MAC802				struct hdr_mac802_11 *mh = HDR_MAC802
											
			if ((u_int32_t) ch->size() < macmib_.				if ((u_int32_t) ch->size() < macmib_.
			    || (u_int32_t) ETHER_ADDR(mh->dh_				    || (u_int32_t) ETHER_ADDR(mh->dh_
				rTime = (Random::random() % c					rTime = (Random::random() % c
					* phymib_.getSlotTime						* phymib_.getSlotTime
				mhDefer_.start(phymib_.getDIF					mhDefer_.start(phymib_.getDIF
                        } else {				                        } else {
				mhDefer_.start(phymib_.getSIF					mhDefer_.start(phymib_.getSIF
                        }					                        }
		}								}
	} else if(callback_) {						} else if(callback_) {
		Handler *h = callback_;						Handler *h = callback_;
		callback_ = 0;							callback_ = 0;
		h->handle((Event*) 0);						h->handle((Event*) 0);
	}								}
	setTxState(MAC_IDLE);						setTxState(MAC_IDLE);
}								}

void								void
Mac802_11::rx_resume()						Mac802_11::rx_resume()
{								{
	assert(pktRx_ == 0);						assert(pktRx_ == 0);
	assert(mhRecv_.busy() == 0);					assert(mhRecv_.busy() == 0);
	setRxState(MAC_IDLE);						setRxState(MAC_IDLE);
}								}


/* ==========================================================	/* ==========================================================
   Timer Handler Routines					   Timer Handler Routines
   ==========================================================	   ==========================================================
void								void
Mac802_11::backoffHandler()					Mac802_11::backoffHandler()
{								{
	if(pktCTRL_) {							if(pktCTRL_) {
		assert(mhSend_.busy() || mhDefer_.busy());			assert(mhSend_.busy() || mhDefer_.busy());
		return;								return;
	}								}

	if(check_pktRTS() == 0)						if(check_pktRTS() == 0)
		return;								return;

	if(check_pktTx() == 0)						if(check_pktTx() == 0)
		return;								return;
}								}

void								void
Mac802_11::deferHandler()					Mac802_11::deferHandler()
{								{
	assert(pktCTRL_ || pktRTS_ || pktTx_);				assert(pktCTRL_ || pktRTS_ || pktTx_);

	if(check_pktCTRL() == 0)					if(check_pktCTRL() == 0)
		return;								return;
	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);
	if(check_pktRTS() == 0)						if(check_pktRTS() == 0)
		return;								return;
	if(check_pktTx() == 0)						if(check_pktTx() == 0)
		return;								return;
}								}

void								void
Mac802_11::navHandler()						Mac802_11::navHandler()
{								{
	if(is_idle() && mhBackoff_.paused())				if(is_idle() && mhBackoff_.paused())
		mhBackoff_.resume(phymib_.getDIFS());				mhBackoff_.resume(phymib_.getDIFS());
}								}

void								void
Mac802_11::recvHandler()					Mac802_11::recvHandler()
{								{
	recv_timer();							recv_timer();
}								}

void								void
Mac802_11::sendHandler()					Mac802_11::sendHandler()
{								{
	send_timer();							send_timer();
}								}


void								void
Mac802_11::txHandler()						Mac802_11::txHandler()
{								{
	if (EOTtarget_) {						if (EOTtarget_) {
		assert(eotPacket_);						assert(eotPacket_);
		EOTtarget_->recv(eotPacket_, (Handler *) 0);			EOTtarget_->recv(eotPacket_, (Handler *) 0);
		eotPacket_ = NULL;						eotPacket_ = NULL;
	}								}
	tx_active_ = 0;							tx_active_ = 0;
}								}


/* ==========================================================	/* ==========================================================
   The "real" Timer Handler Routines				   The "real" Timer Handler Routines
   ==========================================================	   ==========================================================
void								void
Mac802_11::send_timer()						Mac802_11::send_timer()
{								{
	switch(tx_state_) {						switch(tx_state_) {
	/*								/*
	 * Sent a RTS, but did not receive a CTS.			 * Sent a RTS, but did not receive a CTS.
	 */								 */
	case MAC_RTS:							case MAC_RTS:
		RetransmitRTS();						RetransmitRTS();
		break;								break;
	/*								/*
	 * Sent a CTS, but did not receive a DATA packet.		 * Sent a CTS, but did not receive a DATA packet.
	 */								 */
	case MAC_CTS:							case MAC_CTS:
		assert(pktCTRL_);						assert(pktCTRL_);
		Packet::free(pktCTRL_); 					Packet::free(pktCTRL_); 
		pktCTRL_ = 0;							pktCTRL_ = 0;
		break;								break;
	/*								/*
	 * Sent DATA, but did not receive an ACK packet.		 * Sent DATA, but did not receive an ACK packet.
	 */								 */
	case MAC_SEND:							case MAC_SEND:
		RetransmitDATA();						RetransmitDATA();
		break;								break;
	/*								/*
	 * Sent an ACK, and now ready to resume transmission.		 * Sent an ACK, and now ready to resume transmission.
	 */								 */
	case MAC_ACK:							case MAC_ACK:
		assert(pktCTRL_);						assert(pktCTRL_);
		Packet::free(pktCTRL_); 					Packet::free(pktCTRL_); 
		pktCTRL_ = 0;							pktCTRL_ = 0;
		break;								break;
	case MAC_JAM:							case MAC_JAM:
		assert(pktJAM_);						assert(pktJAM_);
		Packet::free(pktJAM_);						Packet::free(pktJAM_);
		pktJAM_ = 0;							pktJAM_ = 0;
		break;								break;
	case MAC_IDLE:							case MAC_IDLE:
		break;								break;
	default:							default:
		assert(0);							assert(0);
	}								}
	tx_resume();							tx_resume();
}								}


/* ==========================================================	/* ==========================================================
   Outgoing Packet Routines					   Outgoing Packet Routines
   ==========================================================	   ==========================================================
int								int
Mac802_11::check_pktCTRL()					Mac802_11::check_pktCTRL()
{								{
	struct hdr_mac802_11 *mh;					struct hdr_mac802_11 *mh;
	double timeout;							double timeout;

	if(pktCTRL_ == 0)						if(pktCTRL_ == 0)
		return -1;							return -1;
	if(tx_state_ == MAC_CTS || tx_state_ == MAC_ACK)		if(tx_state_ == MAC_CTS || tx_state_ == MAC_ACK)
		return -1;							return -1;

	mh = HDR_MAC802_11(pktCTRL_);					mh = HDR_MAC802_11(pktCTRL_);
							  								  
	switch(mh->dh_fc.fc_subtype) {					switch(mh->dh_fc.fc_subtype) {
	/*								/*
	 *  If the medium is not IDLE, don't send the CTS.		 *  If the medium is not IDLE, don't send the CTS.
	 */								 */
	case MAC_Subtype_CTS:						case MAC_Subtype_CTS:
		if(!is_idle()) {						if(!is_idle()) {
			discard(pktCTRL_, DROP_MAC_BUSY); pkt				discard(pktCTRL_, DROP_MAC_BUSY); pkt
			return 0;							return 0;
		}								}
		setTxState(MAC_CTS);						setTxState(MAC_CTS);
		/*								/*
		 * timeout:  cts + data tx time calculated by			 * timeout:  cts + data tx time calculated by
		 *           adding cts tx time to the cts du			 *           adding cts tx time to the cts du
		 *           minus ack tx time -- this timeou			 *           minus ack tx time -- this timeou
		 *           a guess since it is unspecified			 *           a guess since it is unspecified
		 *           (note: mh->dh_duration == cf->cf			 *           (note: mh->dh_duration == cf->cf
		 */								 */		
		 timeout = txtime(phymib_.getCTSlen(), basicR			 timeout = txtime(phymib_.getCTSlen(), basicR
                        + DSSS_MaxPropagationDelay           	                        + DSSS_MaxPropagationDelay           
                        + sec(mh->dh_duration)			                        + sec(mh->dh_duration)
                        + DSSS_MaxPropagationDelay           	                        + DSSS_MaxPropagationDelay           
                       - phymib_.getSIFS()			                       - phymib_.getSIFS()
                       - txtime(phymib_.getACKlen(), basicRat	                       - txtime(phymib_.getACKlen(), basicRat
		break;								break;
		/*								/*
		 * IEEE 802.11 specs, section 9.2.8				 * IEEE 802.11 specs, section 9.2.8
		 * Acknowledments are sent after an SIFS, wit			 * Acknowledments are sent after an SIFS, wit
		 * the busy/idle state of the medium.				 * the busy/idle state of the medium.
		 */								 */
	case MAC_Subtype_ACK:						case MAC_Subtype_ACK:		
		setTxState(MAC_ACK);						setTxState(MAC_ACK);
		timeout = txtime(phymib_.getACKlen(), basicRa			timeout = txtime(phymib_.getACKlen(), basicRa
		break;								break;
	default:							default:
		fprintf(stderr, "check_pktCTRL:Invalid MAC Co			fprintf(stderr, "check_pktCTRL:Invalid MAC Co
		exit(1);							exit(1);
	}								}
	transmit(pktCTRL_, timeout);					transmit(pktCTRL_, timeout);
	return 0;							return 0;
}								}

int								int
Mac802_11::check_pktRTS()					Mac802_11::check_pktRTS()
{								{
	struct hdr_mac802_11 *mh;					struct hdr_mac802_11 *mh;
	double timeout;							double timeout;

	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);

	if(pktRTS_ == 0)						if(pktRTS_ == 0)
 		return -1;					 		return -1;
	mh = HDR_MAC802_11(pktRTS_);					mh = HDR_MAC802_11(pktRTS_);

 	switch(mh->dh_fc.fc_subtype) {				 	switch(mh->dh_fc.fc_subtype) {
	case MAC_Subtype_RTS:						case MAC_Subtype_RTS:
		if(! is_idle()) {						if(! is_idle()) {
			inc_cw();							inc_cw();
			mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());
			return 0;							return 0;
		}								}
		setTxState(MAC_RTS);						setTxState(MAC_RTS);
		timeout = txtime(phymib_.getRTSlen(), basicRa			timeout = txtime(phymib_.getRTSlen(), basicRa
			+ DSSS_MaxPropagationDelay           				+ DSSS_MaxPropagationDelay           
			+ phymib_.getSIFS()						+ phymib_.getSIFS()
			+ txtime(phymib_.getCTSlen(), basicRa				+ txtime(phymib_.getCTSlen(), basicRa
			+ DSSS_MaxPropagationDelay;					+ DSSS_MaxPropagationDelay;
		break;								break;
	default:							default:
		fprintf(stderr, "check_pktRTS:Invalid MAC Con			fprintf(stderr, "check_pktRTS:Invalid MAC Con
		exit(1);							exit(1);
	}								}
	transmit(pktRTS_, timeout);					transmit(pktRTS_, timeout);
  								  

	return 0;							return 0;
}								}

int								int
Mac802_11::check_pktTx()					Mac802_11::check_pktTx()
{								{
							      >		check_pktTx();
	struct hdr_mac802_11 *mh;					struct hdr_mac802_11 *mh;
	double timeout;							double timeout;
									
	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);

	if(pktTx_ == 0)							if(pktTx_ == 0)
		return -1;							return -1;

	mh = HDR_MAC802_11(pktTx_);					mh = HDR_MAC802_11(pktTx_);

	switch(mh->dh_fc.fc_subtype) {					switch(mh->dh_fc.fc_subtype) {
	case MAC_Subtype_Data:						case MAC_Subtype_Data:
		if(! is_idle()) {						if(! is_idle()) {
			sendRTS(ETHER_ADDR(mh->dh_ra));					sendRTS(ETHER_ADDR(mh->dh_ra));
			inc_cw();							inc_cw();
			mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());
			return 0;							return 0;
		}								}
		setTxState(MAC_SEND);						setTxState(MAC_SEND);
		if((u_int32_t)ETHER_ADDR(mh->dh_ra) != MAC_BR			if((u_int32_t)ETHER_ADDR(mh->dh_ra) != MAC_BR
                        timeout = txtime(pktTx_)		                        timeout = txtime(pktTx_)
                                + DSSS_MaxPropagationDelay   	                                + DSSS_MaxPropagationDelay   
                               + phymib_.getSIFS()		                               + phymib_.getSIFS()
                               + txtime(phymib_.getACKlen(), 	                               + txtime(phymib_.getACKlen(), 
                               + DSSS_MaxPropagationDelay;   	                               + DSSS_MaxPropagationDelay;   
		else								else
			timeout = txtime(pktTx_);					timeout = txtime(pktTx_);
		break;								break;
	default:							default:
		fprintf(stderr, "check_pktTx:Invalid MAC Cont			fprintf(stderr, "check_pktTx:Invalid MAC Cont
		exit(1);							exit(1);
	}								}
	transmit(pktTx_, timeout);					transmit(pktTx_, timeout);
	return 0;							return 0;
}								}
int								int
Mac802_11::check_pktJAM()					Mac802_11::check_pktJAM()
{								{
	/*								/*
	 * I will check to see if I need need to Jam			 * I will check to see if I need need to Jam
	 * by entering in a Polling Loop Waiting for the next		 * by entering in a Polling Loop Waiting for the next
	 * Packet/ Frame to be sent, and then cause contentio		 * Packet/ Frame to be sent, and then cause contentio
	 */								 */
	struct hdr_mac802_11 *mh;			      <
	if(pktJAM_ == 0)						if(pktJAM_ == 0)
		return -1;							return -1;
	/*								/*
	 * Need to add Some Kind of Conditional timer or      |		 * need to add some kind of conditional timer or
	 * interupt timer here with a conditional VAR	      |		 * interupt timer here with a conditional var
	 */								 */
	mh = HDR_MAC802_11(pktJAM_);			      |		struct hdr_mac802_11 *mh = HDR_MAC802_11(pktJAM_);
							      |		hdr_jadecoin *hdr = HDR_JADECOIN(pktJAM_);	
	mhJam_.start((double)((u_int32_t) mh->dh_ta));	      |		mhJam_.start((double)(hdr->timeout()));
									
	while((rx_state_ != MAC_SEND) && (mhJam_.busy()))		while((rx_state_ != MAC_SEND) && (mhJam_.busy()))
	{								{
		//Poll Waiting for a Valid user to send Traff |			//poll waiting for a valid user to send traff
	} 								} 
	if(!mhJam_.busy())						if(!mhJam_.busy())
	{								{
		discard(pktJAM_, DROP_MAC_JAM_0);				discard(pktJAM_, DROP_MAC_JAM_0);
		pktJAM_ = 0;							pktJAM_ = 0;
		fprintf(stderr, "check_pktJam:Jamming Timed O |			fprintf(stderr, "check_pktjam:jamming timed o
		return -1;							return -1;
	}								}
	switch(mh->dh_fc.fc_subtype)					switch(mh->dh_fc.fc_subtype)
	{								{
		case MAC_Subtype_NO_JAM:					case MAC_Subtype_NO_JAM:
				discard(pktJAM_, DROP_MAC_NO_					discard(pktJAM_, DROP_MAC_NO_
				pktJAM_ =0;							pktJAM_ =0;
				return 0;							return 0;
		case MAC_Subtype_JAM:						case MAC_Subtype_JAM:
				setTxState(MAC_JAM);						setTxState(MAC_JAM);
				break;								break;
		default:							default:
				fprintf(stderr, "check_pktJam					fprintf(stderr, "check_pktJam
	}								}
	transmit(pktJAM_,0.000000001);					transmit(pktJAM_,0.000000001);
	return 0;							return 0;
}								}
/*								/*
 * Low-level transmit functions that actually place the packe	 * Low-level transmit functions that actually place the packe
 * the channel.							 * the channel.
 */								 */

void								void
Mac802_11::sendRTS(int dst)					Mac802_11::sendRTS(int dst)
{								{
	Packet *p = Packet::alloc();					Packet *p = Packet::alloc();
	hdr_cmn* ch = HDR_CMN(p);					hdr_cmn* ch = HDR_CMN(p);
	struct rts_frame *rf = (struct rts_frame*)p->access(h		struct rts_frame *rf = (struct rts_frame*)p->access(h
									
	assert(pktTx_);							assert(pktTx_);
	assert(pktRTS_ == 0);						assert(pktRTS_ == 0);

	/*								/*
	 *  If the size of the packet is larger than the		 *  If the size of the packet is larger than the
	 *  RTSThreshold, then perform the RTS/CTS exchange.		 *  RTSThreshold, then perform the RTS/CTS exchange.
	 */								 */
	if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.get		if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.get
            (u_int32_t) dst == MAC_BROADCAST) {			            (u_int32_t) dst == MAC_BROADCAST) {
		Packet::free(p);						Packet::free(p);
		return;								return;
	}								}

	ch->uid() = 0;							ch->uid() = 0;
	ch->ptype() = PT_MAC;						ch->ptype() = PT_MAC;
	ch->size() = phymib_.getRTSlen();				ch->size() = phymib_.getRTSlen();
	ch->iface() = -2;						ch->iface() = -2;
	ch->error() = 0;						ch->error() = 0;

	bzero(rf, MAC_HDR_LEN);						bzero(rf, MAC_HDR_LEN);

	rf->rf_fc.fc_protocol_version = MAC_ProtocolVersion;		rf->rf_fc.fc_protocol_version = MAC_ProtocolVersion;
 	rf->rf_fc.fc_type	= MAC_Type_Control;		 	rf->rf_fc.fc_type	= MAC_Type_Control;
 	rf->rf_fc.fc_subtype	= MAC_Subtype_RTS;		 	rf->rf_fc.fc_subtype	= MAC_Subtype_RTS;
 	rf->rf_fc.fc_to_ds	= 0;				 	rf->rf_fc.fc_to_ds	= 0;
 	rf->rf_fc.fc_from_ds	= 0;				 	rf->rf_fc.fc_from_ds	= 0;
 	rf->rf_fc.fc_more_frag	= 0;				 	rf->rf_fc.fc_more_frag	= 0;
 	rf->rf_fc.fc_retry	= 0;				 	rf->rf_fc.fc_retry	= 0;
 	rf->rf_fc.fc_pwr_mgt	= 0;				 	rf->rf_fc.fc_pwr_mgt	= 0;
 	rf->rf_fc.fc_more_data	= 0;				 	rf->rf_fc.fc_more_data	= 0;
 	rf->rf_fc.fc_wep	= 0;				 	rf->rf_fc.fc_wep	= 0;
 	rf->rf_fc.fc_order	= 0;				 	rf->rf_fc.fc_order	= 0;

	//rf->rf_duration = RTS_DURATION(pktTx_);			//rf->rf_duration = RTS_DURATION(pktTx_);
	STORE4BYTE(&dst, (rf->rf_ra));					STORE4BYTE(&dst, (rf->rf_ra));
									
	/* store rts tx time */						/* store rts tx time */
 	ch->txtime() = txtime(ch->size(), basicRate_);		 	ch->txtime() = txtime(ch->size(), basicRate_);
									
	STORE4BYTE(&index_, (rf->rf_ta));				STORE4BYTE(&index_, (rf->rf_ta));

	/* calculate rts duration field */				/* calculate rts duration field */	
	rf->rf_duration = usec(phymib_.getSIFS()			rf->rf_duration = usec(phymib_.getSIFS()
			       + txtime(phymib_.getCTSlen(), 				       + txtime(phymib_.getCTSlen(), 
			       + phymib_.getSIFS()					       + phymib_.getSIFS()
                               + txtime(pktTx_)			                               + txtime(pktTx_)
			       + phymib_.getSIFS()					       + phymib_.getSIFS()
			       + txtime(phymib_.getACKlen(), 				       + txtime(phymib_.getACKlen(), 
	pktRTS_ = p;							pktRTS_ = p;
}								}

void								void
Mac802_11::sendCTS(int dst, double rts_duration)		Mac802_11::sendCTS(int dst, double rts_duration)
{								{
	Packet *p = Packet::alloc();					Packet *p = Packet::alloc();
	hdr_cmn* ch = HDR_CMN(p);					hdr_cmn* ch = HDR_CMN(p);
	struct cts_frame *cf = (struct cts_frame*)p->access(h		struct cts_frame *cf = (struct cts_frame*)p->access(h

	assert(pktCTRL_ == 0);						assert(pktCTRL_ == 0);

	ch->uid() = 0;							ch->uid() = 0;
	ch->ptype() = PT_MAC;						ch->ptype() = PT_MAC;
	ch->size() = phymib_.getCTSlen();				ch->size() = phymib_.getCTSlen();


	ch->iface() = -2;						ch->iface() = -2;
	ch->error() = 0;						ch->error() = 0;
	//ch->direction() = hdr_cmn::DOWN;				//ch->direction() = hdr_cmn::DOWN;
	bzero(cf, MAC_HDR_LEN);						bzero(cf, MAC_HDR_LEN);

	cf->cf_fc.fc_protocol_version = MAC_ProtocolVersion;		cf->cf_fc.fc_protocol_version = MAC_ProtocolVersion;
	cf->cf_fc.fc_type	= MAC_Type_Control;			cf->cf_fc.fc_type	= MAC_Type_Control;
	cf->cf_fc.fc_subtype	= MAC_Subtype_CTS;			cf->cf_fc.fc_subtype	= MAC_Subtype_CTS;
 	cf->cf_fc.fc_to_ds	= 0;				 	cf->cf_fc.fc_to_ds	= 0;
 	cf->cf_fc.fc_from_ds	= 0;				 	cf->cf_fc.fc_from_ds	= 0;
 	cf->cf_fc.fc_more_frag	= 0;				 	cf->cf_fc.fc_more_frag	= 0;
 	cf->cf_fc.fc_retry	= 0;				 	cf->cf_fc.fc_retry	= 0;
 	cf->cf_fc.fc_pwr_mgt	= 0;				 	cf->cf_fc.fc_pwr_mgt	= 0;
 	cf->cf_fc.fc_more_data	= 0;				 	cf->cf_fc.fc_more_data	= 0;
 	cf->cf_fc.fc_wep	= 0;				 	cf->cf_fc.fc_wep	= 0;
 	cf->cf_fc.fc_order	= 0;				 	cf->cf_fc.fc_order	= 0;
									
	//cf->cf_duration = CTS_DURATION(rts_duration);			//cf->cf_duration = CTS_DURATION(rts_duration);
	STORE4BYTE(&dst, (cf->cf_ra));					STORE4BYTE(&dst, (cf->cf_ra));
									
	/* store cts tx time */						/* store cts tx time */
	ch->txtime() = txtime(ch->size(), basicRate_);			ch->txtime() = txtime(ch->size(), basicRate_);
									
	/* calculate cts duration */					/* calculate cts duration */
	cf->cf_duration = usec(sec(rts_duration)			cf->cf_duration = usec(sec(rts_duration)
                              - phymib_.getSIFS()		                              - phymib_.getSIFS()
                              - txtime(phymib_.getCTSlen(), b	                              - txtime(phymib_.getCTSlen(), b


									
	pktCTRL_ = p;							pktCTRL_ = p;
									
}								}

void								void
Mac802_11::sendACK(int dst)					Mac802_11::sendACK(int dst)
{								{
	Packet *p = Packet::alloc();					Packet *p = Packet::alloc();
	hdr_cmn* ch = HDR_CMN(p);					hdr_cmn* ch = HDR_CMN(p);
	struct ack_frame *af = (struct ack_frame*)p->access(h		struct ack_frame *af = (struct ack_frame*)p->access(h

	assert(pktCTRL_ == 0);						assert(pktCTRL_ == 0);

	ch->uid() = 0;							ch->uid() = 0;
	ch->ptype() = PT_MAC;						ch->ptype() = PT_MAC;
	// CHANGE WRT Mike's code					// CHANGE WRT Mike's code
	ch->size() = phymib_.getACKlen();				ch->size() = phymib_.getACKlen();
	ch->iface() = -2;						ch->iface() = -2;
	ch->error() = 0;						ch->error() = 0;
									
	bzero(af, MAC_HDR_LEN);						bzero(af, MAC_HDR_LEN);

	af->af_fc.fc_protocol_version = MAC_ProtocolVersion;		af->af_fc.fc_protocol_version = MAC_ProtocolVersion;
 	af->af_fc.fc_type	= MAC_Type_Control;		 	af->af_fc.fc_type	= MAC_Type_Control;
 	af->af_fc.fc_subtype	= MAC_Subtype_ACK;		 	af->af_fc.fc_subtype	= MAC_Subtype_ACK;
 	af->af_fc.fc_to_ds	= 0;				 	af->af_fc.fc_to_ds	= 0;
 	af->af_fc.fc_from_ds	= 0;				 	af->af_fc.fc_from_ds	= 0;
 	af->af_fc.fc_more_frag	= 0;				 	af->af_fc.fc_more_frag	= 0;
 	af->af_fc.fc_retry	= 0;				 	af->af_fc.fc_retry	= 0;
 	af->af_fc.fc_pwr_mgt	= 0;				 	af->af_fc.fc_pwr_mgt	= 0;
 	af->af_fc.fc_more_data	= 0;				 	af->af_fc.fc_more_data	= 0;
 	af->af_fc.fc_wep	= 0;				 	af->af_fc.fc_wep	= 0;
 	af->af_fc.fc_order	= 0;				 	af->af_fc.fc_order	= 0;

	//af->af_duration = ACK_DURATION();				//af->af_duration = ACK_DURATION();
	STORE4BYTE(&dst, (af->af_ra));					STORE4BYTE(&dst, (af->af_ra));

	/* store ack tx time */						/* store ack tx time */
 	ch->txtime() = txtime(ch->size(), basicRate_);		 	ch->txtime() = txtime(ch->size(), basicRate_);
									
	/* calculate ack duration */					/* calculate ack duration */
 	af->af_duration = 0;					 	af->af_duration = 0;	
									
	pktCTRL_ = p;							pktCTRL_ = p;
}								}
void								void
Mac802_11::sendJAM(Packet *p)					Mac802_11::sendJAM(Packet *p)
{								{
							      >		hdr_jadecoin* hdr = HDR_JADECOIN(p);
	hdr_cmn* ch = HDR_CMN(p);					hdr_cmn* ch = HDR_CMN(p);
	struct hdr_mac802_11* dh = HDR_MAC802_11(p);			struct hdr_mac802_11* dh = HDR_MAC802_11(p);
							      |		getNodeCount();
							      >		getBandwidthUsage();
	assert(pktJAM_ == 0);						assert(pktJAM_ == 0);
	/*								/*
	 * Update Mac Header						 * Update Mac Header
	 */								 */
	dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;		dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;
	dh->dh_fc.fc_type       = MAC_Type_JAM;				dh->dh_fc.fc_type       = MAC_Type_JAM;
	if ((u_int32_t)ETHER_ADDR(dh->dh_ra) == MAC_JAM_SENTI |		if ((u_int32_t)ETHER_ADDR(hdr->sendCode()) == MAC_JAM
		dh->dh_fc.fc_subtype    = MAC_Subtype_JAM;			dh->dh_fc.fc_subtype    = MAC_Subtype_JAM;
	else								else
		dh->dh_fc.fc_subtype 		= MAC_Subtype			dh->dh_fc.fc_subtype 		= MAC_Subtype
							      |			
	dh->dh_fc.fc_to_ds      = 0;					dh->dh_fc.fc_to_ds      = 0;
	dh->dh_fc.fc_from_ds    = 0;					dh->dh_fc.fc_from_ds    = 0;
	dh->dh_fc.fc_more_frag  = 0;					dh->dh_fc.fc_more_frag  = 0;
	dh->dh_fc.fc_retry      = 0;					dh->dh_fc.fc_retry      = 0;
	dh->dh_fc.fc_pwr_mgt    = 0;					dh->dh_fc.fc_pwr_mgt    = 0;
	dh->dh_fc.fc_more_data  = 0;					dh->dh_fc.fc_more_data  = 0;
	dh->dh_fc.fc_wep        = 0;					dh->dh_fc.fc_wep        = 0;
	dh->dh_fc.fc_order      = 0;					dh->dh_fc.fc_order      = 0;

	/* store data tx time */					/* store data tx time */
 	ch->txtime() = txtime(ch->size(), dataRate_);		 	ch->txtime() = txtime(ch->size(), dataRate_);

	if((u_int32_t)ETHER_ADDR(dh->dh_ra) != MAC_BROADCAST)		if((u_int32_t)ETHER_ADDR(dh->dh_ra) != MAC_BROADCAST)
		/* store data tx time for unicast packets */			/* store data tx time for unicast packets */
		ch->txtime() = txtime(ch->size(), dataRate_);			ch->txtime() = txtime(ch->size(), dataRate_);
										
		dh->dh_duration = usec(txtime(phymib_.getACKl			dh->dh_duration = usec(txtime(phymib_.getACKl
				       + phymib_.getSIFS());					       + phymib_.getSIFS());

	} else {							} else {
		/* store data tx time for broadcast packets (			/* store data tx time for broadcast packets (
		ch->txtime() = txtime(ch->size(), basicRate_)			ch->txtime() = txtime(ch->size(), basicRate_)
										
		dh->dh_duration = 0;						dh->dh_duration = 0;
	}								}
	pktJAM_ = p;							pktJAM_ = p;
}								}
void								void
Mac802_11::sendDATA(Packet *p)					Mac802_11::sendDATA(Packet *p)
{								{
	hdr_cmn* ch = HDR_CMN(p);					hdr_cmn* ch = HDR_CMN(p);
	struct hdr_mac802_11* dh = HDR_MAC802_11(p);			struct hdr_mac802_11* dh = HDR_MAC802_11(p);

	assert(pktTx_ == 0);						assert(pktTx_ == 0);

	/*								/*
	 * Update the MAC header					 * Update the MAC header
	 */								 */
	ch->size() += phymib_.getHdrLen11();				ch->size() += phymib_.getHdrLen11();

	dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;		dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;
	dh->dh_fc.fc_type       = MAC_Type_Data;			dh->dh_fc.fc_type       = MAC_Type_Data;
	dh->dh_fc.fc_subtype    = MAC_Subtype_Data;			dh->dh_fc.fc_subtype    = MAC_Subtype_Data;
									
	dh->dh_fc.fc_to_ds      = 0;					dh->dh_fc.fc_to_ds      = 0;
	dh->dh_fc.fc_from_ds    = 0;					dh->dh_fc.fc_from_ds    = 0;
	dh->dh_fc.fc_more_frag  = 0;					dh->dh_fc.fc_more_frag  = 0;
	dh->dh_fc.fc_retry      = 0;					dh->dh_fc.fc_retry      = 0;
	dh->dh_fc.fc_pwr_mgt    = 0;					dh->dh_fc.fc_pwr_mgt    = 0;
	dh->dh_fc.fc_more_data  = 0;					dh->dh_fc.fc_more_data  = 0;
	dh->dh_fc.fc_wep        = 0;					dh->dh_fc.fc_wep        = 0;
	dh->dh_fc.fc_order      = 0;					dh->dh_fc.fc_order      = 0;

	/* store data tx time */					/* store data tx time */
 	ch->txtime() = txtime(ch->size(), dataRate_);		 	ch->txtime() = txtime(ch->size(), dataRate_);

	if((u_int32_t)ETHER_ADDR(dh->dh_ra) != MAC_BROADCAST)		if((u_int32_t)ETHER_ADDR(dh->dh_ra) != MAC_BROADCAST)
		/* store data tx time for unicast packets */			/* store data tx time for unicast packets */
		ch->txtime() = txtime(ch->size(), dataRate_);			ch->txtime() = txtime(ch->size(), dataRate_);
										
		dh->dh_duration = usec(txtime(phymib_.getACKl			dh->dh_duration = usec(txtime(phymib_.getACKl
				       + phymib_.getSIFS());					       + phymib_.getSIFS());


	} else {							} else {
		/* store data tx time for broadcast packets (			/* store data tx time for broadcast packets (
		ch->txtime() = txtime(ch->size(), basicRate_)			ch->txtime() = txtime(ch->size(), basicRate_)
										
		dh->dh_duration = 0;						dh->dh_duration = 0;
	}								}
	pktTx_ = p;							pktTx_ = p;
}								}

/* ==========================================================	/* ==========================================================
   Retransmission Routines					   Retransmission Routines
   ==========================================================	   ==========================================================
void								void
Mac802_11::RetransmitRTS()					Mac802_11::RetransmitRTS()
{								{
	assert(pktTx_);							assert(pktTx_);
	assert(pktRTS_);						assert(pktRTS_);
	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);
	macmib_.RTSFailureCount++;					macmib_.RTSFailureCount++;


	ssrc_ += 1;			// STA Short Retry Co		ssrc_ += 1;			// STA Short Retry Co
										
	if(ssrc_ >= macmib_.getShortRetryLimit()) {			if(ssrc_ >= macmib_.getShortRetryLimit()) {
		discard(pktRTS_, DROP_MAC_RETRY_COUNT_EXCEEDE			discard(pktRTS_, DROP_MAC_RETRY_COUNT_EXCEEDE
		/* tell the callback the send operation faile			/* tell the callback the send operation faile
		   before discarding the packet */				   before discarding the packet */
		hdr_cmn *ch = HDR_CMN(pktTx_);					hdr_cmn *ch = HDR_CMN(pktTx_);
		if (ch->xmit_failure_) {					if (ch->xmit_failure_) {
                        /*					                        /*
                         *  Need to remove the MAC header so 	                         *  Need to remove the MAC header so 
                         *  re-cycled packets don't keep gett	                         *  re-cycled packets don't keep gett
                         *  bigger.				                         *  bigger.
                         */					                         */
			ch->size() -= phymib_.getHdrLen11();				ch->size() -= phymib_.getHdrLen11();
                        ch->xmit_reason_ = XMIT_REASON_RTS;	                        ch->xmit_reason_ = XMIT_REASON_RTS;
                        ch->xmit_failure_(pktTx_->copy(),	                        ch->xmit_failure_(pktTx_->copy(),
                                          ch->xmit_failure_da	                                          ch->xmit_failure_da
                }						                }
		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED			discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED
		pktTx_ = 0;							pktTx_ = 0;
		ssrc_ = 0;							ssrc_ = 0;
		rst_cw();							rst_cw();
	} else {							} else {
		struct rts_frame *rf;						struct rts_frame *rf;
		rf = (struct rts_frame*)pktRTS_->access(hdr_m			rf = (struct rts_frame*)pktRTS_->access(hdr_m
		rf->rf_fc.fc_retry = 1;						rf->rf_fc.fc_retry = 1;

		inc_cw();							inc_cw();
		mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());
	}								}
}								}

void								void
Mac802_11::RetransmitDATA()					Mac802_11::RetransmitDATA()
{								{
	struct hdr_cmn *ch;						struct hdr_cmn *ch;
	struct hdr_mac802_11 *mh;					struct hdr_mac802_11 *mh;
	u_int32_t *rcount, thresh;					u_int32_t *rcount, thresh;
	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);

	assert(pktTx_);							assert(pktTx_);
	assert(pktRTS_ == 0);						assert(pktRTS_ == 0);

	ch = HDR_CMN(pktTx_);						ch = HDR_CMN(pktTx_);
	mh = HDR_MAC802_11(pktTx_);					mh = HDR_MAC802_11(pktTx_);

	/*								/*
	 *  Broadcast packets don't get ACKed and therefore		 *  Broadcast packets don't get ACKed and therefore
	 *  are never retransmitted.					 *  are never retransmitted.
	 */								 */
	if((u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST)		if((u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST)
		Packet::free(pktTx_); 						Packet::free(pktTx_); 
		pktTx_ = 0;							pktTx_ = 0;

		/*								/*
		 * Backoff at end of TX.					 * Backoff at end of TX.
		 */								 */
		rst_cw();							rst_cw();
		mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());

		return;								return;
	}								}

	macmib_.ACKFailureCount++;					macmib_.ACKFailureCount++;

	if((u_int32_t) ch->size() <= macmib_.getRTSThreshold(		if((u_int32_t) ch->size() <= macmib_.getRTSThreshold(
                rcount = &ssrc_;				                rcount = &ssrc_;
               thresh = macmib_.getShortRetryLimit();		               thresh = macmib_.getShortRetryLimit();
        } else {						        } else {
                rcount = &slrc_;				                rcount = &slrc_;
               thresh = macmib_.getLongRetryLimit();		               thresh = macmib_.getLongRetryLimit();
        }							        }

	(*rcount)++;							(*rcount)++;

	if(*rcount >= thresh) {						if(*rcount >= thresh) {
		/* IEEE Spec section 9.2.3.5 says this should			/* IEEE Spec section 9.2.3.5 says this should
		   or equal */							   or equal */
		macmib_.FailedCount++;						macmib_.FailedCount++;
		/* tell the callback the send operation faile			/* tell the callback the send operation faile
		   before discarding the packet */				   before discarding the packet */
		hdr_cmn *ch = HDR_CMN(pktTx_);					hdr_cmn *ch = HDR_CMN(pktTx_);
		if (ch->xmit_failure_) {					if (ch->xmit_failure_) {
                        ch->size() -= phymib_.getHdrLen11();	                        ch->size() -= phymib_.getHdrLen11();
			ch->xmit_reason_ = XMIT_REASON_ACK;				ch->xmit_reason_ = XMIT_REASON_ACK;
                        ch->xmit_failure_(pktTx_->copy(),	                        ch->xmit_failure_(pktTx_->copy(),
                                          ch->xmit_failure_da	                                          ch->xmit_failure_da
                }						                }

		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED			discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED
		pktTx_ = 0;							pktTx_ = 0;
		*rcount = 0;							*rcount = 0;
		rst_cw();							rst_cw();
	}								}
	else {								else {
		struct hdr_mac802_11 *dh;					struct hdr_mac802_11 *dh;
		dh = HDR_MAC802_11(pktTx_);					dh = HDR_MAC802_11(pktTx_);
		dh->dh_fc.fc_retry = 1;						dh->dh_fc.fc_retry = 1;


		sendRTS(ETHER_ADDR(mh->dh_ra));					sendRTS(ETHER_ADDR(mh->dh_ra));
		inc_cw();							inc_cw();
		mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());
	}								}
}								}

/* ==========================================================	/* ==========================================================
   Incoming Packet Routines					   Incoming Packet Routines
   ==========================================================	   ==========================================================
void								void
Mac802_11::send(Packet *p, Handler *h)				Mac802_11::send(Packet *p, Handler *h)
{								{
	double rTime;							double rTime;
	struct hdr_mac802_11 *dh = HDR_MAC802_11(p);			struct hdr_mac802_11 *dh = HDR_MAC802_11(p);

	EnergyModel *em = netif_->node()->energy_model();		EnergyModel *em = netif_->node()->energy_model();
	if (em && em->sleep()) {					if (em && em->sleep()) {
		em->set_node_sleep(0);						em->set_node_sleep(0);
		em->set_node_state(EnergyModel::INROUTE);			em->set_node_state(EnergyModel::INROUTE);
	}								}
									
	callback_ = h;							callback_ = h;
	if ((ETHER_ADDR(dh->dh_ra) == MAC_JAM_SENTINEL) || 		if ((ETHER_ADDR(dh->dh_ra) == MAC_JAM_SENTINEL) || 
	 		(ETHER_ADDR(dh->dh_ra) == MAC_NO_JAM_		 		(ETHER_ADDR(dh->dh_ra) == MAC_NO_JAM_
	{								{
			sendJAM(p);			      |				//sendJAM(p);
			return;								return;
	}								}
									
									
	sendDATA(p);							sendDATA(p);
	sendRTS(ETHER_ADDR(dh->dh_ra));					sendRTS(ETHER_ADDR(dh->dh_ra));

	/*								/*
	 * Assign the data packet a sequence number.			 * Assign the data packet a sequence number.
	 */								 */
	dh->dh_scontrol = sta_seqno_++;					dh->dh_scontrol = sta_seqno_++;

	/*								/*
	 *  If the medium is IDLE, we must wait for a DIFS		 *  If the medium is IDLE, we must wait for a DIFS
	 *  Space before transmitting.					 *  Space before transmitting.
	 */								 */
	if(mhBackoff_.busy() == 0) {					if(mhBackoff_.busy() == 0) {
		if(is_idle()) {							if(is_idle()) {
			if (mhDefer_.busy() == 0) {					if (mhDefer_.busy() == 0) {
				/*								/*
				 * If we are already deferrin					 * If we are already deferrin
				 * need to reset the Defer ti					 * need to reset the Defer ti
				 */								 */
				rTime = (Random::random() % c					rTime = (Random::random() % c
					* (phymib_.getSlotTim						* (phymib_.getSlotTim
				mhDefer_.start(phymib_.getDIF					mhDefer_.start(phymib_.getDIF
			}								}
		} else {							} else {
			/*								/*
			 * If the medium is NOT IDLE, then we				 * If the medium is NOT IDLE, then we
			 * the backoff timer.						 * the backoff timer.
			 */								 */
			mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());
		}								}
	}								}
}								}

void								void
Mac802_11::recv(Packet *p, Handler *h)				Mac802_11::recv(Packet *p, Handler *h)
{								{
	struct hdr_cmn *hdr = HDR_CMN(p);				struct hdr_cmn *hdr = HDR_CMN(p);
	/*								/*
	 * Sanity Check							 * Sanity Check
	 */								 */
	assert(initialized());						assert(initialized());

	/*								/*
	 *  Handle outgoing packets.					 *  Handle outgoing packets.
	 */								 */
	if(hdr->direction() == hdr_cmn::DOWN) {				if(hdr->direction() == hdr_cmn::DOWN) {
                send(p, h);					                send(p, h);
                return;						                return;
        }							        }
	/*								/*
	 *  Handle incoming packets.					 *  Handle incoming packets.
	 *								 *
	 *  We just received the 1st bit of a packet on the n		 *  We just received the 1st bit of a packet on the n
	 *  interface.							 *  interface.
	 *								 *
	 */								 */

	/*								/*
	 *  If the interface is currently in transmit mode, t		 *  If the interface is currently in transmit mode, t
	 *  it probably won't even see this packet.  However,		 *  it probably won't even see this packet.  However,
	 *  "air" around me is BUSY so I need to let the pack		 *  "air" around me is BUSY so I need to let the pack
	 *  proceed.  Just set the error flag in the common h		 *  proceed.  Just set the error flag in the common h
	 *  to that the packet gets thrown away.			 *  to that the packet gets thrown away.
	 */								 */
	if(tx_active_ && hdr->error() == 0) {				if(tx_active_ && hdr->error() == 0) {
		hdr->error() = 1;						hdr->error() = 1;
	}								}

	if(rx_state_ == MAC_IDLE) {					if(rx_state_ == MAC_IDLE) {
		setRxState(MAC_RECV);						setRxState(MAC_RECV);
		pktRx_ = p;							pktRx_ = p;
		/*								/*
		 * Schedule the reception of this packet, in			 * Schedule the reception of this packet, in
		 * txtime seconds.						 * txtime seconds.
		 */								 */
		mhRecv_.start(txtime(p));					mhRecv_.start(txtime(p));
	} else {							} else {
		/*								/*
		 *  If the power of the incoming packet is sm			 *  If the power of the incoming packet is sm
		 *  power of the packet currently being recei			 *  power of the packet currently being recei
                 *  the capture threshold, then we ignore the	                 *  the capture threshold, then we ignore the
		 */								 */
		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= 			if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= 
			capture(p);							capture(p);
		} else {							} else {
			collision(p);							collision(p);
		}								}
	}								}
}								}

void								void
Mac802_11::recv_timer()						Mac802_11::recv_timer()
{								{
	u_int32_t src; 							u_int32_t src; 
	hdr_cmn *ch = HDR_CMN(pktRx_);					hdr_cmn *ch = HDR_CMN(pktRx_);
	hdr_mac802_11 *mh = HDR_MAC802_11(pktRx_);			hdr_mac802_11 *mh = HDR_MAC802_11(pktRx_);
	u_int32_t dst = ETHER_ADDR(mh->dh_ra);				u_int32_t dst = ETHER_ADDR(mh->dh_ra);
									
	u_int8_t  type = mh->dh_fc.fc_type;				u_int8_t  type = mh->dh_fc.fc_type;
	u_int8_t  subtype = mh->dh_fc.fc_subtype;			u_int8_t  subtype = mh->dh_fc.fc_subtype;

	assert(pktRx_);							assert(pktRx_);
	assert(rx_state_ == MAC_RECV || rx_state_ == MAC_COLL		assert(rx_state_ == MAC_RECV || rx_state_ == MAC_COLL
									
        /*							        /*
         *  If the interface is in TRANSMIT mode when this pa	         *  If the interface is in TRANSMIT mode when this pa
         *  "arrives", then I would never have seen it and sh	         *  "arrives", then I would never have seen it and sh
         *  do a silent discard without adjusting the NAV.	         *  do a silent discard without adjusting the NAV.
         */							         */
        if(tx_active_) {					        if(tx_active_) {
                Packet::free(pktRx_);				                Packet::free(pktRx_);
                goto done;					                goto done;
        }							        }

	/*								/*
	 * Handle collisions.						 * Handle collisions.
	 */								 */
	if(rx_state_ == MAC_COLL) {					if(rx_state_ == MAC_COLL) {
		discard(pktRx_, DROP_MAC_COLLISION);				discard(pktRx_, DROP_MAC_COLLISION);	
		set_nav(usec(phymib_.getEIFS()));				set_nav(usec(phymib_.getEIFS()));
		goto done;							goto done;
	}								}

	/*								/*
	 * Check to see if this packet was received with enou		 * Check to see if this packet was received with enou
	 * bit errors that the current level of FEC still cou		 * bit errors that the current level of FEC still cou
	 * fix all of the problems - ie; after FEC, the check		 * fix all of the problems - ie; after FEC, the check
	 * failed.							 * failed.
	 */								 */
	if( ch->error() ) {						if( ch->error() ) {
		Packet::free(pktRx_);						Packet::free(pktRx_);
		set_nav(usec(phymib_.getEIFS()));				set_nav(usec(phymib_.getEIFS()));
		goto done;							goto done;
	}								}

	/*								/*
	 * IEEE 802.11 specs, section 9.2.5.6				 * IEEE 802.11 specs, section 9.2.5.6
	 *	- update the NAV (Network Allocation Vector)		 *	- update the NAV (Network Allocation Vector)
	 */								 */
	if(dst != (u_int32_t)index_) {					if(dst != (u_int32_t)index_) {
		set_nav(mh->dh_duration);					set_nav(mh->dh_duration);
	}								}

        /* tap out - */						        /* tap out - */
        if (tap_ && type == MAC_Type_Data &&			        if (tap_ && type == MAC_Type_Data &&
            MAC_Subtype_Data == subtype ) 			            MAC_Subtype_Data == subtype ) 
		tap_->tap(pktRx_);						tap_->tap(pktRx_);
	/*								/*
	 * Adaptive Fidelity Algorithm Support - neighborhood		 * Adaptive Fidelity Algorithm Support - neighborhood
	 * collection							 * collection
	 *								 *
	 * Hacking: Before filter the packet, log the neighbo		 * Hacking: Before filter the packet, log the neighbo
	 * I can hear the packet, the src is my neighbor		 * I can hear the packet, the src is my neighbor
	 */								 */
	if (netif_->node()->energy_model() && 				if (netif_->node()->energy_model() && 
	    netif_->node()->energy_model()->adaptivefidelity(		    netif_->node()->energy_model()->adaptivefidelity(
		src = ETHER_ADDR(mh->dh_ta);					src = ETHER_ADDR(mh->dh_ta);
		netif_->node()->energy_model()->add_neighbor(			netif_->node()->energy_model()->add_neighbor(
	}								}
	/*								/*
	 * Address Filtering						 * Address Filtering
	 */								 */
	if(dst != (u_int32_t)index_ && dst != MAC_BROADCAST) 		if(dst != (u_int32_t)index_ && dst != MAC_BROADCAST) 
		/*								/*
		 *  We don't want to log this event, so we ju			 *  We don't want to log this event, so we ju
		 *  the packet instead of calling the drop ro			 *  the packet instead of calling the drop ro
		 */								 */
		discard(pktRx_, "---");						discard(pktRx_, "---");
		goto done;							goto done;
	}								}

	switch(type) {							switch(type) {

	case MAC_Type_Management:					case MAC_Type_Management:
		discard(pktRx_, DROP_MAC_PACKET_ERROR);				discard(pktRx_, DROP_MAC_PACKET_ERROR);
		goto done;							goto done;
	case MAC_Type_Control:						case MAC_Type_Control:
		switch(subtype) {						switch(subtype) {
		case MAC_Subtype_RTS:						case MAC_Subtype_RTS:
			recvRTS(pktRx_);						recvRTS(pktRx_);
			break;								break;
		case MAC_Subtype_CTS:						case MAC_Subtype_CTS:
			recvCTS(pktRx_);						recvCTS(pktRx_);
			break;								break;
		case MAC_Subtype_ACK:						case MAC_Subtype_ACK:
			recvACK(pktRx_);						recvACK(pktRx_);
			break;								break;
		default:							default:
			fprintf(stderr,"recvTimer1:Invalid MA				fprintf(stderr,"recvTimer1:Invalid MA
				subtype);							subtype);
			exit(1);							exit(1);
		}								}
		break;								break;
	case MAC_Type_Data:						case MAC_Type_Data:
		switch(subtype) {						switch(subtype) {
		case MAC_Subtype_Data:						case MAC_Subtype_Data:
			recvDATA(pktRx_);						recvDATA(pktRx_);
			break;								break;
		default:							default:
			fprintf(stderr, "recv_timer2:Invalid 				fprintf(stderr, "recv_timer2:Invalid 
				subtype);							subtype);
			exit(1);							exit(1);
		}								}
		break;								break;
	default:							default:
		fprintf(stderr, "recv_timer3:Invalid MAC Type			fprintf(stderr, "recv_timer3:Invalid MAC Type
		exit(1);							exit(1);
	}								}
 done:								 done:
	pktRx_ = 0;							pktRx_ = 0;
	rx_resume();							rx_resume();
}								}


void								void
Mac802_11::recvRTS(Packet *p)					Mac802_11::recvRTS(Packet *p)
{								{
	struct rts_frame *rf = (struct rts_frame*)p->access(h		struct rts_frame *rf = (struct rts_frame*)p->access(h

	if(tx_state_ != MAC_IDLE) {					if(tx_state_ != MAC_IDLE) {
		discard(p, DROP_MAC_BUSY);					discard(p, DROP_MAC_BUSY);
		return;								return;
	}								}

	/*								/*
	 *  If I'm responding to someone else, discard this R		 *  If I'm responding to someone else, discard this R
	 */								 */
	if(pktCTRL_) {							if(pktCTRL_) {
		discard(p, DROP_MAC_BUSY);					discard(p, DROP_MAC_BUSY);
		return;								return;
	}								}

	sendCTS(ETHER_ADDR(rf->rf_ta), rf->rf_duration);		sendCTS(ETHER_ADDR(rf->rf_ta), rf->rf_duration);

	/*								/*
	 *  Stop deferring - will be reset in tx_resume().		 *  Stop deferring - will be reset in tx_resume().
	 */								 */
	if(mhDefer_.busy()) mhDefer_.stop();				if(mhDefer_.busy()) mhDefer_.stop();

	tx_resume();							tx_resume();

	mac_log(p);							mac_log(p);
}								}

/*								/*
 * txtime()	- pluck the precomputed tx time from the pack	 * txtime()	- pluck the precomputed tx time from the pack
 */								 */
double								double
Mac802_11::txtime(Packet *p)					Mac802_11::txtime(Packet *p)
{								{
	struct hdr_cmn *ch = HDR_CMN(p);				struct hdr_cmn *ch = HDR_CMN(p);
	double t = ch->txtime();					double t = ch->txtime();
	if (t < 0.0) {							if (t < 0.0) {
		drop(p, "XXX");							drop(p, "XXX");
 		exit(1);					 		exit(1);
	}								}
	return t;							return t;
}								}

 								 
/*								/*
 * txtime()	- calculate tx time for packet of size "psz" 	 * txtime()	- calculate tx time for packet of size "psz" 
 *		  at rate "drt" bps				 *		  at rate "drt" bps
 */								 */
double								double
Mac802_11::txtime(double psz, double drt)			Mac802_11::txtime(double psz, double drt)
{								{
	double dsz = psz - phymib_.getPLCPhdrLen();			double dsz = psz - phymib_.getPLCPhdrLen();
        int plcp_hdr = phymib_.getPLCPhdrLen() << 3;		        int plcp_hdr = phymib_.getPLCPhdrLen() << 3;	
	int datalen = (int)dsz << 3;					int datalen = (int)dsz << 3;
	double t = (((double)plcp_hdr)/phymib_.getPLCPDataRat		double t = (((double)plcp_hdr)/phymib_.getPLCPDataRat
                                       + (((double)datalen)/d	                                       + (((double)datalen)/d
	return(t);							return(t);
}								}



void								void
Mac802_11::recvCTS(Packet *p)					Mac802_11::recvCTS(Packet *p)
{								{
	if(tx_state_ != MAC_RTS) {					if(tx_state_ != MAC_RTS) {
		discard(p, DROP_MAC_INVALID_STATE);				discard(p, DROP_MAC_INVALID_STATE);
		return;								return;
	}								}

	assert(pktRTS_);						assert(pktRTS_);
	Packet::free(pktRTS_); pktRTS_ = 0;				Packet::free(pktRTS_); pktRTS_ = 0;

	assert(pktTx_);							assert(pktTx_);	
	mhSend_.stop();							mhSend_.stop();

	/*								/*
	 * The successful reception of this CTS packet implie		 * The successful reception of this CTS packet implie
	 * that our RTS was successful. 				 * that our RTS was successful. 
	 * According to the IEEE spec 9.2.5.3, you must 		 * According to the IEEE spec 9.2.5.3, you must 
	 * reset the ssrc_, but not the congestion window.		 * reset the ssrc_, but not the congestion window.
	 */								 */
	ssrc_ = 0;							ssrc_ = 0;
	tx_resume();							tx_resume();

	mac_log(p);							mac_log(p);
}								}

void								void
Mac802_11::recvJAM()						Mac802_11::recvJAM()
{								{
	if (rx_state_ == MAC_COLL)			      |		bool collision = false;
		mhCollision_.collide();			      |		if (rx_state_ != MAC_COLL)
	else						      |		{
		mhCollision_.noCollide();		      |			this->uptarget_->recv((Packet *) collision,(H
							      >			return;
							      >		}
							      >		collision = true;
							      >		this->uptarget_->recv((Packet *) collision, (Handler 
}								}
void								void
Mac802_11::recvDATA(Packet *p)					Mac802_11::recvDATA(Packet *p)
{								{
	struct hdr_mac802_11 *dh = HDR_MAC802_11(p);			struct hdr_mac802_11 *dh = HDR_MAC802_11(p);
	u_int32_t dst, src, size;					u_int32_t dst, src, size;
	struct hdr_cmn *ch = HDR_CMN(p);				struct hdr_cmn *ch = HDR_CMN(p);

	dst = ETHER_ADDR(dh->dh_ra);					dst = ETHER_ADDR(dh->dh_ra);
	src = ETHER_ADDR(dh->dh_ta);					src = ETHER_ADDR(dh->dh_ta);
	size = ch->size();						size = ch->size();
	/*								/*
	 * Adjust the MAC packet size - ie; strip			 * Adjust the MAC packet size - ie; strip
	 * off the mac header						 * off the mac header
	 */								 */
	ch->size() -= phymib_.getHdrLen11();				ch->size() -= phymib_.getHdrLen11();
	ch->num_forwards() += 1;					ch->num_forwards() += 1;

	/*								/*
	 *  If we sent a CTS, clean up...				 *  If we sent a CTS, clean up...
	 */								 */
	if(dst != MAC_BROADCAST) {					if(dst != MAC_BROADCAST) {
		if(size >= macmib_.getRTSThreshold()) {				if(size >= macmib_.getRTSThreshold()) {
			if (tx_state_ == MAC_CTS) {					if (tx_state_ == MAC_CTS) {
				assert(pktCTRL_);						assert(pktCTRL_);
				Packet::free(pktCTRL_); pktCT					Packet::free(pktCTRL_); pktCT
				mhSend_.stop();							mhSend_.stop();
				/*								/*
				 * Our CTS got through.						 * Our CTS got through.
				 */								 */
			} else {							} else {
				discard(p, DROP_MAC_BUSY);					discard(p, DROP_MAC_BUSY);
				return;								return;
			}								}
			sendACK(src);							sendACK(src);
			tx_resume();							tx_resume();
		} else {							} else {
			/*								/*
			 *  We did not send a CTS and there's				 *  We did not send a CTS and there's
			 *  room to buffer an ACK.					 *  room to buffer an ACK.
			 */								 */
			if(pktCTRL_) {							if(pktCTRL_) {
				discard(p, DROP_MAC_BUSY);					discard(p, DROP_MAC_BUSY);
				return;								return;
			}								}
			sendACK(src);							sendACK(src);
			if(mhSend_.busy() == 0)						if(mhSend_.busy() == 0)
				tx_resume();							tx_resume();
		}								}
	}								}
									
	/* ==================================================		/* ==================================================
	   Make/update an entry in our sequence number cache.		   Make/update an entry in our sequence number cache.
	   ==================================================		   ==================================================

	/* Changed by Debojyoti Dutta. This upper loop of if{		/* Changed by Debojyoti Dutta. This upper loop of if{
	   suggested by Joerg Diederich <dieder@ibr.cs.tu-bs.		   suggested by Joerg Diederich <dieder@ibr.cs.tu-bs.
	   Changed on 19th Oct'2000 */					   Changed on 19th Oct'2000 */

        if(dst != MAC_BROADCAST) {				        if(dst != MAC_BROADCAST) {
                if (src < (u_int32_t) cache_node_count_) {	                if (src < (u_int32_t) cache_node_count_) {
                        Host *h = &cache_[src];			                        Host *h = &cache_[src];

                        if(h->seqno && h->seqno == dh->dh_sco	                        if(h->seqno && h->seqno == dh->dh_sco
                                discard(p, DROP_MAC_DUPLICATE	                                discard(p, DROP_MAC_DUPLICATE
                                return;				                                return;
                        }					                        }
                        h->seqno = dh->dh_scontrol;		                        h->seqno = dh->dh_scontrol;
                } else {					                } else {
			static int count = 0;						static int count = 0;
			if (++count <= 10) {						if (++count <= 10) {
				printf ("MAC_802_11: accessin					printf ("MAC_802_11: accessin
				if (count == 10)						if (count == 10)
					printf ("[suppressing						printf ("[suppressing
			};								};
		};								};
	}								}

	/*								/*
	 *  Pass the packet up to the link-layer.			 *  Pass the packet up to the link-layer.
	 *  XXX - we could schedule an event to account			 *  XXX - we could schedule an event to account
	 *  for this processing delay.					 *  for this processing delay.
	 */								 */
									
	/* in BSS mode, if a station receives a packet via		/* in BSS mode, if a station receives a packet via
	 * the AP, and higher layers are interested in lookin		 * the AP, and higher layers are interested in lookin
	 * at the src address, we might need to put it at		 * at the src address, we might need to put it at
	 * the right place - lest the higher layers end up		 * the right place - lest the higher layers end up
	 * believing the AP address to be the src addr! a qui		 * believing the AP address to be the src addr! a qui
	 * grep didn't turn up any higher layers interested i		 * grep didn't turn up any higher layers interested i
	 * the src addr though!						 * the src addr though!
	 * anyway, here if I'm the AP and the destination		 * anyway, here if I'm the AP and the destination
	 * address (in dh_3a) isn't me, then we have to fwd		 * address (in dh_3a) isn't me, then we have to fwd
	 * the packet; we pick the real destination and set		 * the packet; we pick the real destination and set
	 * set it up for the LL; we save the real src into		 * set it up for the LL; we save the real src into
	 * the dh_3a field for the 'interested in the info'		 * the dh_3a field for the 'interested in the info'
	 * receiver; we finally push the packet towards the		 * receiver; we finally push the packet towards the
	 * LL to be added back to my queue - accomplish this		 * LL to be added back to my queue - accomplish this
	 * by reversing the direction!*/				 * by reversing the direction!*/

	if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh		if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh
		struct hdr_cmn *ch = HDR_CMN(p);				struct hdr_cmn *ch = HDR_CMN(p);
		u_int32_t dst = ETHER_ADDR(dh->dh_3a);				u_int32_t dst = ETHER_ADDR(dh->dh_3a);
		u_int32_t src = ETHER_ADDR(dh->dh_ta);				u_int32_t src = ETHER_ADDR(dh->dh_ta);
		/* if it is a broadcast pkt then send a copy 			/* if it is a broadcast pkt then send a copy 
		 * my stack also						 * my stack also
		 */								 */
		if (dst == MAC_BROADCAST) {					if (dst == MAC_BROADCAST) {
			uptarget_->recv(p->copy(), (Handler*)				uptarget_->recv(p->copy(), (Handler*)
		}								}

		ch->next_hop() = dst;						ch->next_hop() = dst;
		STORE4BYTE(&src, (dh->dh_3a));					STORE4BYTE(&src, (dh->dh_3a));
		ch->addr_type() = NS_AF_ILINK;					ch->addr_type() = NS_AF_ILINK;
		ch->direction() = hdr_cmn::DOWN;				ch->direction() = hdr_cmn::DOWN;
	}								}
	recvJAM();					      |		if (listenForCollisions)
							      >			//recvJAM();
	uptarget_->recv(p, (Handler*) 0);				uptarget_->recv(p, (Handler*) 0);
}								}


void								void
Mac802_11::recvACK(Packet *p)					Mac802_11::recvACK(Packet *p)
{								{	
	struct hdr_cmn *ch = HDR_CMN(p);				struct hdr_cmn *ch = HDR_CMN(p);

	if(tx_state_ != MAC_SEND) {					if(tx_state_ != MAC_SEND) {
		discard(p, DROP_MAC_INVALID_STATE);				discard(p, DROP_MAC_INVALID_STATE);
		return;								return;
	}								}
	assert(pktTx_);							assert(pktTx_);

	mhSend_.stop();							mhSend_.stop();

	/*								/*
	 * The successful reception of this ACK packet implie		 * The successful reception of this ACK packet implie
	 * that our DATA transmission was successful.  Hence,		 * that our DATA transmission was successful.  Hence,
	 * we can reset the Short/Long Retry Count and the CW		 * we can reset the Short/Long Retry Count and the CW
	 *								 *
	 * need to check the size of the packet we sent that'		 * need to check the size of the packet we sent that'
	 * ACK'd, not the size of the ACK packet.			 * ACK'd, not the size of the ACK packet.
	 */								 */
	if((u_int32_t) HDR_CMN(pktTx_)->size() <= macmib_.get		if((u_int32_t) HDR_CMN(pktTx_)->size() <= macmib_.get
		ssrc_ = 0;							ssrc_ = 0;
	else								else
		slrc_ = 0;							slrc_ = 0;
	rst_cw();							rst_cw();
	Packet::free(pktTx_); 						Packet::free(pktTx_); 
	pktTx_ = 0;							pktTx_ = 0;
									
	/*								/*
	 * Backoff before sending again.				 * Backoff before sending again.
	 */								 */
	assert(mhBackoff_.busy() == 0);					assert(mhBackoff_.busy() == 0);
	mhBackoff_.start(cw_, is_idle());				mhBackoff_.start(cw_, is_idle());

	tx_resume();							tx_resume();

	mac_log(p);							mac_log(p);
}								}
